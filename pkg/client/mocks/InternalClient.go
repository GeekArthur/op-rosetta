// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	big "math/big"

	common "github.com/ethereum/go-ethereum/common"

	configuration "github.com/coinbase/rosetta-geth-sdk/configuration"

	context "context"

	coretypes "github.com/ethereum/go-ethereum/core/types"

	ethereum "github.com/ethereum/go-ethereum"

	json "encoding/json"

	mock "github.com/stretchr/testify/mock"

	rosetta_geth_sdkclient "github.com/coinbase/rosetta-geth-sdk/client"

	rpc "github.com/ethereum/go-ethereum/rpc"

	types "github.com/coinbase/rosetta-sdk-go/types"
)

// InternalClient is an autogenerated mock type for the InternalClient type
type InternalClient struct {
	mock.Mock
}

// Balance provides a mock function with given fields: ctx, account, block, currencies
func (_m *InternalClient) Balance(ctx context.Context, account *types.AccountIdentifier, block *types.PartialBlockIdentifier, currencies []*types.Currency) (*types.AccountBalanceResponse, error) {
	ret := _m.Called(ctx, account, block, currencies)

	var r0 *types.AccountBalanceResponse
	if rf, ok := ret.Get(0).(func(context.Context, *types.AccountIdentifier, *types.PartialBlockIdentifier, []*types.Currency) *types.AccountBalanceResponse); ok {
		r0 = rf(ctx, account, block, currencies)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.AccountBalanceResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.AccountIdentifier, *types.PartialBlockIdentifier, []*types.Currency) error); ok {
		r1 = rf(ctx, account, block, currencies)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchCallContext provides a mock function with given fields: ctx, b
func (_m *InternalClient) BatchCallContext(ctx context.Context, b []rpc.BatchElem) error {
	ret := _m.Called(ctx, b)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []rpc.BatchElem) error); ok {
		r0 = rf(ctx, b)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BlockAuthor provides a mock function with given fields: ctx, blockIndex
func (_m *InternalClient) BlockAuthor(ctx context.Context, blockIndex int64) (string, error) {
	ret := _m.Called(ctx, blockIndex)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, int64) string); ok {
		r0 = rf(ctx, blockIndex)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, blockIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlockRewardTransaction provides a mock function with given fields: blockIdentifier, miner, uncles
func (_m *InternalClient) BlockRewardTransaction(blockIdentifier *types.BlockIdentifier, miner string, uncles []*coretypes.Header) *types.Transaction {
	ret := _m.Called(blockIdentifier, miner, uncles)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*types.BlockIdentifier, string, []*coretypes.Header) *types.Transaction); ok {
		r0 = rf(blockIdentifier, miner, uncles)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	return r0
}

// CallContext provides a mock function with given fields: ctx, result, method, args
func (_m *InternalClient) CallContext(ctx context.Context, result interface{}, method string, args ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, ctx, result, method)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, string, ...interface{}) error); ok {
		r0 = rf(ctx, result, method, args...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// EstimateGas provides a mock function with given fields: ctx, msg
func (_m *InternalClient) EstimateGas(ctx context.Context, msg ethereum.CallMsg) (uint64, error) {
	ret := _m.Called(ctx, msg)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, ethereum.CallMsg) uint64); ok {
		r0 = rf(ctx, msg)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ethereum.CallMsg) error); ok {
		r1 = rf(ctx, msg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockReceipts provides a mock function with given fields: ctx, blockHash, txs, baseFee
func (_m *InternalClient) GetBlockReceipts(ctx context.Context, blockHash common.Hash, txs []rosetta_geth_sdkclient.RPCTransaction, baseFee *big.Int) ([]*rosetta_geth_sdkclient.RosettaTxReceipt, error) {
	ret := _m.Called(ctx, blockHash, txs, baseFee)

	var r0 []*rosetta_geth_sdkclient.RosettaTxReceipt
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, []rosetta_geth_sdkclient.RPCTransaction, *big.Int) []*rosetta_geth_sdkclient.RosettaTxReceipt); ok {
		r0 = rf(ctx, blockHash, txs, baseFee)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*rosetta_geth_sdkclient.RosettaTxReceipt)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, []rosetta_geth_sdkclient.RPCTransaction, *big.Int) error); ok {
		r1 = rf(ctx, blockHash, txs, baseFee)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClient provides a mock function with given fields:
func (_m *InternalClient) GetClient() *rosetta_geth_sdkclient.SDKClient {
	ret := _m.Called()

	var r0 *rosetta_geth_sdkclient.SDKClient
	if rf, ok := ret.Get(0).(func() *rosetta_geth_sdkclient.SDKClient); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rosetta_geth_sdkclient.SDKClient)
		}
	}

	return r0
}

// GetContractCallGasLimit provides a mock function with given fields: ctx, toAddress, fromAddress, data
func (_m *InternalClient) GetContractCallGasLimit(ctx context.Context, toAddress string, fromAddress string, data []byte) (uint64, error) {
	ret := _m.Called(ctx, toAddress, fromAddress, data)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []byte) uint64); ok {
		r0 = rf(ctx, toAddress, fromAddress, data)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, []byte) error); ok {
		r1 = rf(ctx, toAddress, fromAddress, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractCurrency provides a mock function with given fields: addr, erc20
func (_m *InternalClient) GetContractCurrency(addr common.Address, erc20 bool) (*rosetta_geth_sdkclient.ContractCurrency, error) {
	ret := _m.Called(addr, erc20)

	var r0 *rosetta_geth_sdkclient.ContractCurrency
	if rf, ok := ret.Get(0).(func(common.Address, bool) *rosetta_geth_sdkclient.ContractCurrency); ok {
		r0 = rf(addr, erc20)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rosetta_geth_sdkclient.ContractCurrency)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address, bool) error); ok {
		r1 = rf(addr, erc20)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetErc20TransferGasLimit provides a mock function with given fields: ctx, toAddress, fromAddress, value, currency
func (_m *InternalClient) GetErc20TransferGasLimit(ctx context.Context, toAddress string, fromAddress string, value *big.Int, currency *types.Currency) (uint64, error) {
	ret := _m.Called(ctx, toAddress, fromAddress, value, currency)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *big.Int, *types.Currency) uint64); ok {
		r0 = rf(ctx, toAddress, fromAddress, value, currency)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, *big.Int, *types.Currency) error); ok {
		r1 = rf(ctx, toAddress, fromAddress, value, currency)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGasPrice provides a mock function with given fields: ctx, input
func (_m *InternalClient) GetGasPrice(ctx context.Context, input rosetta_geth_sdkclient.Options) (*big.Int, error) {
	ret := _m.Called(ctx, input)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(context.Context, rosetta_geth_sdkclient.Options) *big.Int); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, rosetta_geth_sdkclient.Options) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLoadedTransaction provides a mock function with given fields: ctx, request
func (_m *InternalClient) GetLoadedTransaction(ctx context.Context, request *types.BlockTransactionRequest) (*rosetta_geth_sdkclient.LoadedTransaction, error) {
	ret := _m.Called(ctx, request)

	var r0 *rosetta_geth_sdkclient.LoadedTransaction
	if rf, ok := ret.Get(0).(func(context.Context, *types.BlockTransactionRequest) *rosetta_geth_sdkclient.LoadedTransaction); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rosetta_geth_sdkclient.LoadedTransaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.BlockTransactionRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNativeTransferGasLimit provides a mock function with given fields: ctx, toAddress, fromAddress, value
func (_m *InternalClient) GetNativeTransferGasLimit(ctx context.Context, toAddress string, fromAddress string, value *big.Int) (uint64, error) {
	ret := _m.Called(ctx, toAddress, fromAddress, value)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *big.Int) uint64); ok {
		r0 = rf(ctx, toAddress, fromAddress, value)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, *big.Int) error); ok {
		r1 = rf(ctx, toAddress, fromAddress, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNonce provides a mock function with given fields: ctx, input
func (_m *InternalClient) GetNonce(ctx context.Context, input rosetta_geth_sdkclient.Options) (uint64, error) {
	ret := _m.Called(ctx, input)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, rosetta_geth_sdkclient.Options) uint64); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, rosetta_geth_sdkclient.Options) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRosettaConfig provides a mock function with given fields:
func (_m *InternalClient) GetRosettaConfig() configuration.RosettaConfig {
	ret := _m.Called()

	var r0 configuration.RosettaConfig
	if rf, ok := ret.Get(0).(func() configuration.RosettaConfig); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(configuration.RosettaConfig)
	}

	return r0
}

// GetTransactionReceipt provides a mock function with given fields: ctx, tx
func (_m *InternalClient) GetTransactionReceipt(ctx context.Context, tx *rosetta_geth_sdkclient.LoadedTransaction) (*rosetta_geth_sdkclient.RosettaTxReceipt, error) {
	ret := _m.Called(ctx, tx)

	var r0 *rosetta_geth_sdkclient.RosettaTxReceipt
	if rf, ok := ret.Get(0).(func(context.Context, *rosetta_geth_sdkclient.LoadedTransaction) *rosetta_geth_sdkclient.RosettaTxReceipt); ok {
		r0 = rf(ctx, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rosetta_geth_sdkclient.RosettaTxReceipt)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *rosetta_geth_sdkclient.LoadedTransaction) error); ok {
		r1 = rf(ctx, tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUncles provides a mock function with given fields: ctx, head, body
func (_m *InternalClient) GetUncles(ctx context.Context, head *coretypes.Header, body *rosetta_geth_sdkclient.RPCBlock) ([]*coretypes.Header, error) {
	ret := _m.Called(ctx, head, body)

	var r0 []*coretypes.Header
	if rf, ok := ret.Get(0).(func(context.Context, *coretypes.Header, *rosetta_geth_sdkclient.RPCBlock) []*coretypes.Header); ok {
		r0 = rf(ctx, head, body)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*coretypes.Header)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *coretypes.Header, *rosetta_geth_sdkclient.RPCBlock) error); ok {
		r1 = rf(ctx, head, body)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseOps provides a mock function with given fields: tx
func (_m *InternalClient) ParseOps(tx *rosetta_geth_sdkclient.LoadedTransaction) ([]*types.Operation, error) {
	ret := _m.Called(tx)

	var r0 []*types.Operation
	if rf, ok := ret.Get(0).(func(*rosetta_geth_sdkclient.LoadedTransaction) []*types.Operation); ok {
		r0 = rf(tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Operation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*rosetta_geth_sdkclient.LoadedTransaction) error); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PopulateCrossChainTransactions provides a mock function with given fields: _a0, _a1
func (_m *InternalClient) PopulateCrossChainTransactions(_a0 *coretypes.Block, _a1 []*rosetta_geth_sdkclient.LoadedTransaction) ([]*types.Transaction, error) {
	ret := _m.Called(_a0, _a1)

	var r0 []*types.Transaction
	if rf, ok := ret.Get(0).(func(*coretypes.Block, []*rosetta_geth_sdkclient.LoadedTransaction) []*types.Transaction); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*coretypes.Block, []*rosetta_geth_sdkclient.LoadedTransaction) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Status provides a mock function with given fields: ctx
func (_m *InternalClient) Status(ctx context.Context) (*types.BlockIdentifier, int64, *types.SyncStatus, []*types.Peer, error) {
	ret := _m.Called(ctx)

	var r0 *types.BlockIdentifier
	if rf, ok := ret.Get(0).(func(context.Context) *types.BlockIdentifier); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockIdentifier)
		}
	}

	var r1 int64
	if rf, ok := ret.Get(1).(func(context.Context) int64); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Get(1).(int64)
	}

	var r2 *types.SyncStatus
	if rf, ok := ret.Get(2).(func(context.Context) *types.SyncStatus); ok {
		r2 = rf(ctx)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(*types.SyncStatus)
		}
	}

	var r3 []*types.Peer
	if rf, ok := ret.Get(3).(func(context.Context) []*types.Peer); ok {
		r3 = rf(ctx)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([]*types.Peer)
		}
	}

	var r4 error
	if rf, ok := ret.Get(4).(func(context.Context) error); ok {
		r4 = rf(ctx)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// Submit provides a mock function with given fields: ctx, signedTx
func (_m *InternalClient) Submit(ctx context.Context, signedTx *coretypes.Transaction) error {
	ret := _m.Called(ctx, signedTx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *coretypes.Transaction) error); ok {
		r0 = rf(ctx, signedTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TraceBlockByHash provides a mock function with given fields: ctx, blockHash, txs
func (_m *InternalClient) TraceBlockByHash(ctx context.Context, blockHash common.Hash, txs []rosetta_geth_sdkclient.RPCTransaction) (map[string][]*rosetta_geth_sdkclient.FlatCall, error) {
	ret := _m.Called(ctx, blockHash, txs)

	var r0 map[string][]*rosetta_geth_sdkclient.FlatCall
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, []rosetta_geth_sdkclient.RPCTransaction) map[string][]*rosetta_geth_sdkclient.FlatCall); ok {
		r0 = rf(ctx, blockHash, txs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]*rosetta_geth_sdkclient.FlatCall)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, []rosetta_geth_sdkclient.RPCTransaction) error); ok {
		r1 = rf(ctx, blockHash, txs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TraceReplayBlockTransactions provides a mock function with given fields: ctx, hsh
func (_m *InternalClient) TraceReplayBlockTransactions(ctx context.Context, hsh string) (map[string][]*rosetta_geth_sdkclient.FlatCall, error) {
	ret := _m.Called(ctx, hsh)

	var r0 map[string][]*rosetta_geth_sdkclient.FlatCall
	if rf, ok := ret.Get(0).(func(context.Context, string) map[string][]*rosetta_geth_sdkclient.FlatCall); ok {
		r0 = rf(ctx, hsh)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]*rosetta_geth_sdkclient.FlatCall)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, hsh)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TraceReplayTransaction provides a mock function with given fields: ctx, hsh
func (_m *InternalClient) TraceReplayTransaction(ctx context.Context, hsh string) (json.RawMessage, []*rosetta_geth_sdkclient.FlatCall, error) {
	ret := _m.Called(ctx, hsh)

	var r0 json.RawMessage
	if rf, ok := ret.Get(0).(func(context.Context, string) json.RawMessage); ok {
		r0 = rf(ctx, hsh)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(json.RawMessage)
		}
	}

	var r1 []*rosetta_geth_sdkclient.FlatCall
	if rf, ok := ret.Get(1).(func(context.Context, string) []*rosetta_geth_sdkclient.FlatCall); ok {
		r1 = rf(ctx, hsh)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*rosetta_geth_sdkclient.FlatCall)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, string) error); ok {
		r2 = rf(ctx, hsh)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// TraceTransaction provides a mock function with given fields: ctx, hash
func (_m *InternalClient) TraceTransaction(ctx context.Context, hash common.Hash) (json.RawMessage, []*rosetta_geth_sdkclient.FlatCall, error) {
	ret := _m.Called(ctx, hash)

	var r0 json.RawMessage
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash) json.RawMessage); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(json.RawMessage)
		}
	}

	var r1 []*rosetta_geth_sdkclient.FlatCall
	if rf, ok := ret.Get(1).(func(context.Context, common.Hash) []*rosetta_geth_sdkclient.FlatCall); ok {
		r1 = rf(ctx, hash)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*rosetta_geth_sdkclient.FlatCall)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, common.Hash) error); ok {
		r2 = rf(ctx, hash)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

type mockConstructorTestingTNewInternalClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewInternalClient creates a new instance of InternalClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewInternalClient(t mockConstructorTestingTNewInternalClient) *InternalClient {
	mock := &InternalClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
